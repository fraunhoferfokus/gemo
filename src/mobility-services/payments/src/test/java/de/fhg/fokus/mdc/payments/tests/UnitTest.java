package de.fhg.fokus.mdc.payments.tests;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;

import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.MultivaluedMap;

import org.codehaus.jackson.JsonParseException;
import org.codehaus.jackson.map.JsonMappingException;
import org.codehaus.jackson.map.ObjectMapper;
import org.junit.Test;

import com.sun.jersey.api.client.Client;
import com.sun.jersey.api.client.ClientHandlerException;
import com.sun.jersey.api.client.ClientResponse;
import com.sun.jersey.api.client.GenericType;
import com.sun.jersey.api.client.UniformInterfaceException;
import com.sun.jersey.api.client.WebResource;
import com.sun.jersey.api.client.config.ClientConfig;
import com.sun.jersey.api.client.config.DefaultClientConfig;
import com.sun.jersey.api.core.ClassNamesResourceConfig;
import com.sun.jersey.api.json.JSONConfiguration;
import com.sun.jersey.core.util.MultivaluedMapImpl;
import com.sun.jersey.spi.container.servlet.WebComponent;
import com.sun.jersey.test.framework.JerseyTest;
import com.sun.jersey.test.framework.WebAppDescriptor;
import com.sun.jersey.test.framework.spi.container.TestContainerFactory;
import com.sun.jersey.test.framework.spi.container.external.ExternalTestContainerFactory;

import de.fhg.fokus.mdc.exceptions.ExpectedBusinessException;
import de.fhg.fokus.mdc.jsonObjects.Payment;
import de.fhg.fokus.mdc.jsonObjects.Reservation;
import de.fhg.fokus.mdc.payments.PaymentService;
import de.fhg.fokus.mdc.payments.exceptions.PaymentNotFoundException;
import de.fhg.fokus.mdc.payments.lib.Consts;

/**
 * TESTs for the payment service. To run the tests you will need:
 * 
 * <pre>
 * 1) Start a test server with storage and payment service 
 * 2) These tests need two existing reservations with _id 1 and 2
 *    and both need reservation segments!
 * 3) if some of the tests throw exceptions, like PaymentAlreadyExistsException, 
 *    delete them in your database and try again.
 * </pre>
 * 
 * @author dsc (Danilo Schmidt, danilo.schmidt@fokus.fraunhofer.de)
 * 
 */

public class UnitTest extends JerseyTest {

	// ----------------[ test vars ]---------------------

	/** testing url */
	private static final String TEST_SERVICEURL = "http://localhost:8080/payments/";
	private static final String TEST_CLEANSERVICEURL = "http://localhost:8080/payments";
	private static final String TEST_RESERVATION_URL = "http://localhost:8080/reservierungEfz/reservations/reserve";

	/** user test id (user with id=1,autom. generated by storage_init script) */
	private static final Integer TEST_USERPROFILEID = 1;
	private static final Integer TEST_RESERVATION_ID1 = 1; // inserted by
															// storage init
															// ("ecar_00025")
	private static final Integer TEST_RESERVATION_ID2 = 2; // inserted by
															// storage init
															// ("ecar_00026")

	/** test reservation sequence (group) id to calculate with */
	private static final Integer TEST_RESERVATIONSEQUENCEID = Integer.MAX_VALUE;

	// ----------------[ basic methods from JerseyTest]---------------------
	@Override
	public WebAppDescriptor configure() {

		return new WebAppDescriptor.Builder()
				.initParam(WebComponent.RESOURCE_CONFIG_CLASS,
						ClassNamesResourceConfig.class.getName())
				.initParam(ClassNamesResourceConfig.PROPERTY_CLASSNAMES,
						PaymentService.class.getName()).build();
	}

	@Override
	protected TestContainerFactory getTestContainerFactory() {
		return new ExternalTestContainerFactory();
	}

	/***********************************************************************
	 ************************ [ Unit Tests ] *******************************
	 ***********************************************************************/

	/**
	 * POST: use case: the client/user consults the payment service with the
	 * current reservation to receive a new payment
	 * 
	 * <pre>
	 * tests: 
	 * 1) does the service create a new payment? 
	 * 2) does the service delete the new payment afterwards?
	 * </pre>
	 * 
	 * @throws JsonParseException
	 * @throws JsonMappingException
	 * @throws IOException
	 */
	@Test
	public void testPOSTCreatePayment() throws JsonParseException,
			JsonMappingException, IOException {
		Payment testPayment = null;
		try {
			testPayment = requestNewPayment(TEST_RESERVATION_ID1);
			/*
			 * ClientResponse response =
			 * requestNewPayment(TEST_RESERVATIONSEQUENCEID - TestID); grab json
			 * as String String json = response.getEntity(String.class);
			 * 
			 * // --------------[ Availability Test ]---------------------
			 * assertEquals("Server-Answer POST: " + json,
			 * ClientResponse.Status.OK.getStatusCode(), response
			 * .getClientResponseStatus().getStatusCode());
			 * 
			 * // protect other tests if
			 * (ClientResponse.Status.OK.getStatusCode() != response
			 * .getClientResponseStatus().getStatusCode()) return;
			 * 
			 * // convert json into object ObjectMapper mapper = new
			 * ObjectMapper(); Payment testPayment = mapper.readValue(json,
			 * Payment.class);
			 */

			// Test 1
			assertFalse("Saved in DB with new _id", testPayment.getId() == -1);
			assertEquals("Right user id", TEST_USERPROFILEID,
					testPayment.getUserprofileID());
			assertEquals("Right reservation sequence id", TEST_RESERVATION_ID1,
					testPayment.getReservationSequenceID());

			// ----------------------[ DELETE]--------------------------
			// Test 2
			boolean removedWithoutException = removePayment(testPayment);
			assertTrue("Server-Answer DELETE: ", removedWithoutException);
		} catch (UniformInterfaceException e) {
			fireExpectedBusinessExceptions(e);
		}
	}

	/**
	 * PUT: use case: the user confirms a requested payment and send it back to
	 * pay
	 * 
	 * <pre>
	 * tests:
	 * 1) does the service update an existing payment the user wants to
	 * 	 confirm?
	 * </pre>
	 * 
	 */
	@Test
	public void testPUTConfirmAndPay() throws JsonParseException,
			JsonMappingException, IOException {
		Payment testPayment = null;
		boolean payedWithoutException = false;
		try {
			// force a business error for internal tests (expect
			// AlreadyExistException)
			// requestNewPayment(TEST_RESERVATIONSEQUENCEID - TestID);

			testPayment = requestNewPayment(TEST_RESERVATION_ID1);

			// ------------[ client interaction (logic) ]------------------

			// confirm the bill (payment)
			testPayment.setConfirmed(true);

			// send back to the service to pay
			payedWithoutException = updatePayment(testPayment);

			// -------------------[ Tests ]---------------------------
			// Test 1
			assertTrue("Server-Answer PUT: ", payedWithoutException);

		} catch (UniformInterfaceException e) {
			fireExpectedBusinessExceptions(e);
		} finally {
			// ----------------------[ DELETE]--------------------------
			removePayment(testPayment);
		}
	}

	/**
	 * GET: all and specific payments of a user
	 * 
	 * <pre>
	 * tests:
	 * 1) does the service receive a list with 2 created payments?
	 * 2) does the service receive a specific payment by id?
	 * </pre>
	 * 
	 * @throws IOException
	 * @throws UniformInterfaceException
	 * @throws ClientHandlerException
	 * @throws JsonMappingException
	 * @throws JsonParseException
	 */
	@Test
	public void test_GET() throws JsonParseException, JsonMappingException,
			ClientHandlerException, UniformInterfaceException, IOException {

		Payment payment1 = null;
		Payment payment2 = null;
		try {
			// define reservation tests
			payment1 = requestNewPayment(TEST_RESERVATION_ID1);
			payment2 = requestNewPayment(TEST_RESERVATION_ID2);

			// -----------------[ Test 1: receive a List ]-------------------
			// GET complete payment list using a jersey Client
			ClientConfig clientConfig = new DefaultClientConfig();
			clientConfig.getFeatures().put(
					JSONConfiguration.FEATURE_POJO_MAPPING, Boolean.TRUE);
			Client client = Client.create(clientConfig);
			List<Payment> payments = client
					.resource(TEST_CLEANSERVICEURL)
					.queryParam(Consts.PARAM_USERPROFILEID,
							TEST_USERPROFILEID.toString())
					.get(new GenericType<List<Payment>>() {
					});

			// Test, expect items in the list
			assertTrue(payments.size() >= 2);

			// -----------------[ Test 2: get single item ]-----------------
			// GET single payment using a jersey WebResource
			WebResource webResource = client().resource(TEST_SERVICEURL);
			String jsonResponse = webResource
					.path(payments.get(0).getId().toString())
					.queryParam(Consts.PARAM_USERPROFILEID,
							TEST_USERPROFILEID.toString()).get(String.class);
			ObjectMapper mapper = new ObjectMapper();
			Payment expectedPayment = mapper.readValue(jsonResponse,
					Payment.class);
			// Test 2, compare the first payment (from list) with this payment
			assertEquals(payments.get(0).getId(), expectedPayment.getId());

		} catch (UniformInterfaceException e) {
			fireExpectedBusinessExceptions(e);
		} finally {
			// ----------------------[ DELETE]--------------------------
			removePayment(payment1);
			removePayment(payment2);
		}
	}

	/**
	 * Test PaymentNotFoundException
	 * 
	 * @throws IOException
	 * @throws JsonMappingException
	 * @throws JsonParseException
	 */
	@Test
	public void test_PaymentNotFoundException() {

		// create a webResource to the target service
		WebResource webResource = client().resource(TEST_SERVICEURL);
		try {
			// fire a request to a specific path with one parameter
			webResource
					.path(((Integer) (TEST_RESERVATIONSEQUENCEID + 1/*
																	 * is
																	 * negative
																	 */))
							.toString())
					.queryParam(Consts.PARAM_USERPROFILEID,
							TEST_USERPROFILEID.toString()).get(String.class);
			// expect an "unexpected" server response as
			// UniformInterfaceException that contains the serialized
			// BusinessException from Server:
		} catch (UniformInterfaceException e) {
			// compare the transfered class type with the expected one of this
			// test
			assertEquals(assertExpectedBusinessExceptionType(e),
					PaymentNotFoundException.class);
		}
	}

	/***********************************************************************
	 ********************** [ Helper Methods ] *****************************
	 ***********************************************************************/

	/**
	 * helper method to parse an unexpected UniformInterfaceException. This
	 * method returns only the class path (type) for a comparison with
	 * assertEquals. Please use fireExpectedBusinessExceptions() to fire
	 * expected business exceptions.
	 * 
	 * <pre>
	 * 	@Test
	 * 	public void myUnitTest(){ 
	 * 		try {
	 * 			webResource.get(...);							//call your service with expected business exceptions:
	 * 		} catch (UniformInterfaceException e) {				//catch unexpected responses from server 
	 * 			assertEquals(assertExpectedBusinessExceptionType(e),//call this method using assertEquals and...
	 * 					PaymentNotFoundException.class);			//check against the ExpectedBusinessException class
	 * 		}
	 * 	}
	 * </pre>
	 * 
	 * @param e
	 * @return
	 */
	private Object assertExpectedBusinessExceptionType(
			UniformInterfaceException e) {
		try {
			// try to find serialized BusinessException in the response body or
			// do nothing
			ExpectedBusinessException.BusinessException businessException = e
					.getResponse().getEntity(
							ExpectedBusinessException.BusinessException.class);
			// create a class type from the passed type and return it
			return Class.forName(businessException.getType());
		} catch (Exception e1) {
			// there is no expected BusinessException, return the
			// UniformInterfaceException
			return e;
		}
	}

	private void fireExpectedBusinessExceptions(UniformInterfaceException e) {
		try {
			// try to find serialized BusinessException in the response body or
			// do nothing
			ExpectedBusinessException.BusinessException businessException = e
					.getResponse().getEntity(
							ExpectedBusinessException.BusinessException.class);
			// throw expected Business Exception
			throw (ExpectedBusinessException) Class
					.forName(businessException.getType())
					.getConstructor(String.class)
					.newInstance(businessException.getMessage());
		} catch (ExpectedBusinessException createdException) {
			// throw away, because this was the goal here ;-)
			// We need this catch-block to be able to react on true exceptions
			// from the creation process
			throw createdException;
		} catch (Exception e2) {
			// there is no expected BusinessException, but the normal
			// UniformInterfaceException or normal exceptions during the
			// creation process
			throw e;
		}
	}

	/**
	 * requests a new Payment using POST
	 * 
	 * @return Response
	 */
	private Payment requestNewPayment(Integer reservationID) {
		/*
		 * // create a rest service client to consume payment service
		 * WebResource service = client().resource(TEST_SERVICEURL);
		 * 
		 * // create a test form for a POST request with the goal to create and
		 * // receive a new payment resource Form form = new Form();
		 * form.add(Consts.PARAM_USERPROFILEID, TEST_USERPROFILEID);
		 * form.add(Consts.PARAM_RESERVATIONSEQUENCEID, reservationID);
		 * 
		 * // return service.type(MediaType.APPLICATION_FORM_URLENCODED).post(
		 * // Payment.class, form);
		 */

		ClientConfig clientConfig = new DefaultClientConfig();
		clientConfig.getFeatures().put(JSONConfiguration.FEATURE_POJO_MAPPING,
				Boolean.TRUE);
		Client client = Client.create(clientConfig);

		MultivaluedMap<String, String> formData = new MultivaluedMapImpl();
		formData.add(Consts.PARAM_USERPROFILEID, TEST_USERPROFILEID.toString());
		formData.add(Consts.PARAM_RESERVATIONSEQUENCEID,
				reservationID.toString());

		return client.resource(TEST_SERVICEURL).post(Payment.class, formData);

	}

	/**
	 * uses the service to update
	 * 
	 * @param payment
	 * @return Boolean
	 */
	private Boolean updatePayment(Payment payment) {

		// create an update url. the service only allows to update the field
		// "confirmed". For this case we only support the equivalent QueryParam
		String updateURL = payment.getId() + "?" + Consts.PARAM_CONFIRMED + "="
				+ payment.getConfirmed().toString() + "&"
				+ Consts.PARAM_USERPROFILEID + "=" + TEST_USERPROFILEID;

		// create a rest service client to consume payment service
		WebResource service = client().resource(TEST_SERVICEURL + updateURL);

		// put the parameters
		service.type(MediaType.TEXT_PLAIN).put();

		return true;
	}

	/**
	 * uses the service to delete TODO this will work until storage supports
	 * return types with generated id
	 * 
	 * @param payment
	 * @return Boolean
	 */
	private Boolean removePayment(Payment payment) {

		if (payment == null)
			return false;

		// create the url
		String deleteUrl = "?" + Consts.PARAM_ID + "=" + payment.getId() + "&"
				+ Consts.PARAM_USERPROFILEID + "=" + payment.getUserprofileID();

		// create a rest service client to consume payment service
		WebResource service = client().resource(TEST_SERVICEURL + deleteUrl);

		// send the form and receive a response we want play with
		service.type(MediaType.TEXT_PLAIN).delete();

		return true;
	}

	/**
	 * create a reservation and return the id for tests
	 * 
	 * @return
	 * @throws IOException
	 * @throws JsonMappingException
	 * @throws JsonParseException
	 */

	private Reservation createTestReservation() throws JsonParseException,
			JsonMappingException, IOException {

		ClientConfig clientConfig = new DefaultClientConfig();
		Client client = Client.create(clientConfig);

		SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd H:m:s");
		Date date = new Date();
		String now = dateFormat.format(date);
		String in30Minutes = dateFormat.format(date.getTime() + (30 * 60000));

		MultivaluedMap<String, String> formData = new MultivaluedMapImpl();
		formData.add(Consts.PARAM_RESERVATION_EVEHICLEID, "ecar_00001");
		formData.add(Consts.PARAM_RESERVATION_USERID,
				TEST_USERPROFILEID.toString());
		formData.add(Consts.PARAM_RESERVATION_TIMEFROM, now);
		formData.add(Consts.PARAM_RESERVATION_TIMETO, in30Minutes);
		formData.add(Consts.PARAM_RESERVATION_LONGSTART, "0");
		formData.add(Consts.PARAM_RESERVATION_LATSTART, "0");
		formData.add(Consts.PARAM_RESERVATION_LONGEND, "0");
		formData.add(Consts.PARAM_RESERVATION_LATEND, "0");
		formData.add(Consts.PARAM_RESERVATION_TYPE, "tour_private"); // gemo.reservation.type
		formData.add(Consts.PARAM_RESERVATION_SEQUENCEID, "?");

		// This client expected no type as response. We will simply get a json
		ClientResponse response = client.resource(TEST_RESERVATION_URL)
				.queryParams(formData).get(ClientResponse.class);
		String json = response.getEntity(String.class);
		Reservation reservation = new ObjectMapper().readValue(json,
				Reservation.class);
		return reservation;
	}

}
